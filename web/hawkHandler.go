package web

import (
	"bytes"
	"crypto/sha256"
	"io/ioutil"
	"net/http"
	"strings"
	"time"

	log "github.com/Sirupsen/logrus"
	"github.com/allegro/bigcache"
	"github.com/mozilla-services/go-syncstorage/token"
	"github.com/pkg/errors"
	"go.mozilla.org/hawk"
)

var (
	EmptyData       = []byte{}
	ErrTokenInvalid = errors.New("Token is invalid")
	ErrTokenExpired = errors.New("Token is expired")
)

type HawkHandler struct {
	handler http.Handler
	cache   *bigcache.BigCache
	secrets []string
}

func NewHawkHandler(handler http.Handler, secrets []string) *HawkHandler {
	cache, err := bigcache.NewBigCache(bigcache.DefaultConfig(time.Minute))
	if err != nil {
		log.WithFields(log.Fields{
			"err": err.Error(),
		}).Panic("Could not create hawk cache")
	}

	return &HawkHandler{
		handler: handler,
		secrets: secrets,
		cache:   cache,
	}
}

func (h *HawkHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	// Step 1: Ensure the Hawk header is OK. Use ParseRequestHeader
	// so the token does not have to be parsed twice to extract
	// the UID from it
	auth, err := hawk.NewAuthFromRequest(r, nil, h.hawkNonceNotFound)
	if err != nil {
		if e, ok := err.(hawk.AuthFormatError); ok {
			sendRequestProblem(w, r, http.StatusBadRequest,
				errors.Errorf("Hawk: Malformed hawk header, field: %s, err: %s", e.Field, e.Err))
		} else if authError, ok := err.(hawk.AuthError); ok {
			w.Header().Set("WWW-Authenticate", "Hawk")
			switch authError {
			case hawk.ErrReplay: // log the replay'd nonce
				authInfo, _ := hawk.ParseRequestHeader(r.Header.Get("Authorization"))
				sendRequestProblem(w, r, http.StatusUnauthorized,
					errors.Errorf("Hawk: Replay nonce=%s", authInfo.Nonce))
			default:
				sendRequestProblem(w, r, http.StatusUnauthorized, errors.Wrap(err, "Hawk: AuthError"))
			}
		} else {
			sendRequestProblem(w, r, http.StatusUnauthorized, errors.Wrap(err, "Hawk: Unknown Error"))
		}
		return
	}

	// Step 2: Extract the Token
	var (
		parsedToken token.Token
		tokenError  error = ErrTokenInvalid
	)

	for _, secret := range h.secrets {
		parsedToken, tokenError = token.ParseToken([]byte(secret), auth.Credentials.ID)
		if tokenError == nil { // found the right secret
			break
		}
	}

	if tokenError != nil {
		sendRequestProblem(w, r, http.StatusBadRequest, errors.Wrap(tokenError, "Hawk: Invalid token"))
		return
	} else {
		// required to these manually so the auth.Valid()
		// check has all the information it needs later
		auth.Credentials.Key = parsedToken.DerivedSecret
		auth.Credentials.Hash = sha256.New
	}

	// Step 3: Make sure it's valid...
	if err := auth.Valid(); err != nil {
		w.Header().Set("WWW-Authenticate", "Hawk")
		sendRequestProblem(w, r, http.StatusUnauthorized, errors.Wrap(err, "Hawk: auth invalid"))
		return
	}

	session := &Session{
		Token: parsedToken.Payload,
	}

	// Step 4: Make sure token UID matches path UID for sync paths
	if strings.HasPrefix(r.URL.Path, "/1.5/") {
		pathUID := extractUID(r.URL.Path)
		if session.Token.UidString() != pathUID {
			sendRequestProblem(w, r, http.StatusBadRequest,
				errors.New("Hawk Sync URL UID != Token UID"))
			return
		}
	}

	// Step 5: Validate the payload hash if it exists
	if auth.Hash != nil {
		if r.Header.Get("Content-Type") == "" {
			sendRequestProblem(w, r, http.StatusBadRequest,
				errors.New("Hawk: Content-Type required"))
			return
		}

		// read and replace io.Reader
		content, err := ioutil.ReadAll(r.Body)
		if err != nil {
			sendRequestProblem(w, r, http.StatusBadRequest,
				errors.Wrap(err, "Hawk: Could not read request body"))
			return
		}

		r.Body = ioutil.NopCloser(bytes.NewReader(content))
		pHash := auth.PayloadHash(r.Header.Get("Content-Type"))
		pHash.Sum(content)
		if !auth.ValidHash(pHash) {
			w.Header().Set("WWW-Authenticate", "Hawk")
			sendRequestProblem(w, r, http.StatusUnauthorized,
				errors.New("Hawk: payload hash invalid"))
			return
		}
	}

	// Step 6: *woot*, pass it on
	reqCtx := r.WithContext(NewSessionContext(r.Context(), session))
	h.handler.ServeHTTP(w, reqCtx)
}

func (h *HawkHandler) hawkNonceNotFound(nonce string, t time.Time, creds *hawk.Credentials) bool {
	// *need that cache*
	diff := time.Now().Sub(t)
	if diff > time.Minute || diff < -time.Minute {
		return false
	}

	// From the Docs:
	//   The nonce is generated by the client, and is a string unique across all
	//   requests with the same timestamp and key identifier combination.

	// since bigcache uses hash/fnv, just make a string for it to hash later
	key := nonce + t.String()
	if creds != nil {
		key = key + creds.ID
	}
	_, err := h.cache.Get(key)

	if err != nil {
		switch err.(type) {
		case bigcache.EntryNotFoundError, *bigcache.EntryNotFoundError:
			h.cache.Set(key, EmptyData)
			return true
		default:
			log.WithFields(log.Fields{
				"err": err.Error(),
			}).Error("HawkAuth - Cache Error")
		}
	}

	return false
}
