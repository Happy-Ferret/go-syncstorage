package web

import (
	"bytes"
	"crypto/sha256"
	"errors"
	"fmt"
	"io/ioutil"
	"net/http"
	"strconv"
	"strings"
	"time"

	log "github.com/Sirupsen/logrus"
	"github.com/allegro/bigcache"
	"github.com/mostlygeek/go-syncstorage/token"
	"go.mozilla.org/hawk"
)

var (
	EmptyData       = []byte{}
	ErrTokenInvalid = errors.New("Token is invalid")
	ErrTokenExpired = errors.New("Token is expired")
)

type HawkHandler struct {
	handler http.Handler
	cache   *bigcache.BigCache
	secrets []string
}

func NewHawkHandler(handler http.Handler, secrets []string) *HawkHandler {
	cache, err := bigcache.NewBigCache(bigcache.DefaultConfig(time.Minute))
	if err != nil {
		log.WithFields(log.Fields{
			"err": err.Error(),
		}).Panic("Could not create hawk cache")
	}

	return &HawkHandler{
		handler: handler,
		secrets: secrets,
		cache:   cache,
	}
}

func (h *HawkHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	// Step 1: Ensure the Hawk header is OK. Use ParseRequestHeader
	// so the token does not have to be parsed twice to extract
	// the UID from it
	auth, err := hawk.NewAuthFromRequest(r, nil, h.hawkNonceNotFound)
	if err != nil {
		if e, ok := err.(hawk.AuthFormatError); ok {
			JSONError(w,
				fmt.Sprintf("Malformed hawk header, field: %s, err: %s", e.Field, e.Err),
				http.StatusBadRequest)
		} else {
			w.Header().Set("WWW-Authenticate", "Hawk")
			http.Error(w, err.Error(), http.StatusUnauthorized)
		}
		return
	}

	// Step 2: Extract the Token
	var (
		parsedToken token.Token
		tokenError  error = ErrTokenInvalid
	)

	for _, secret := range h.secrets {
		parsedToken, tokenError = token.ParseToken([]byte(secret), auth.Credentials.ID)
		if tokenError == nil { // found the right secret
			break
		}
	}

	if tokenError != nil {
		log.WithFields(log.Fields{
			"err": tokenError.Error(),
		}).Info("Hawk token error")

		http.Error(w,
			fmt.Sprintf("Invalid token: %s", tokenError.Error()),
			http.StatusBadRequest)
		return
	} else {
		// required to these manually so the auth.Valid()
		// check has all the information it needs later
		auth.Credentials.Key = parsedToken.DerivedSecret
		auth.Credentials.Hash = sha256.New
	}

	// Step 3: Make sure it's valid...
	if err := auth.Valid(); err != nil {
		w.Header().Set("WWW-Authenticate", "Hawk")
		http.Error(w, err.Error(), http.StatusUnauthorized)
		return
	}

	// Step 4: Make sure token UID matches path UID for sync paths
	if strings.HasPrefix(r.URL.Path, "/1.5/") {
		expecteUID := strconv.FormatUint(parsedToken.Payload.Uid, 10)
		pathUID := extractUID(r.URL.Path)
		if expecteUID != pathUID {
			http.Error(w, "Sync URL UID != Token UID", http.StatusBadRequest)
			return
		}
	}

	// Step 5: Validate the payload hash if it exists
	if auth.Hash != nil {
		if r.Header.Get("Content-Type") == "" {
			http.Error(w, "Content-Type missing", http.StatusBadRequest)
			return
		}

		// read and replace io.Reader
		content, err := ioutil.ReadAll(r.Body)
		if err != nil {
			http.Error(w, "Could not read request body", http.StatusInternalServerError)
			return
		}

		r.Body = ioutil.NopCloser(bytes.NewReader(content))
		pHash := auth.PayloadHash(r.Header.Get("Content-Type"))
		pHash.Sum(content)
		if !auth.ValidHash(pHash) {
			w.Header().Set("WWW-Authenticate", "Hawk")
			http.Error(w, "Hawk error, payload hash invalid", http.StatusUnauthorized)
			return
		}
	}

	// Step 6: *woot*, pass it on
	h.handler.ServeHTTP(w, r)
}

func (h *HawkHandler) hawkNonceNotFound(nonce string, t time.Time, creds *hawk.Credentials) bool {
	// *need that cache*
	diff := time.Now().Sub(t)
	if diff > time.Minute || diff < -time.Minute {
		return false
	}

	// From the Docs:
	//   The nonce is generated by the client, and is a string unique across all
	//   requests with the same timestamp and key identifier combination.

	// since bigcache uses hash/fnv, just make a string for it to hash later
	key := nonce + t.String()
	if creds != nil {
		key = key + creds.ID
	}
	_, err := h.cache.Get(key)

	if err != nil {
		switch err.(type) {
		case bigcache.EntryNotFoundError, *bigcache.EntryNotFoundError:
			h.cache.Set(key, EmptyData)
			return true
		default:
			log.WithFields(log.Fields{
				"err": err.Error(),
			}).Error("HawkAuth - Cache Error")
		}
	}

	return false
}
